import { ApiService } from '@/api/api.service';
import { isDev } from '@/contants/isDev';
import { backKeyboard, mainKeyboard } from '@/contants/keyboards';
import { BOT_DENIED } from '@/contants/messages';
import { requisites } from '@/contants/requisites';
import { SendToOwner } from '@/types/SendToOwner';
import { convertBytes } from '@/utils/convertBytes';
import { escapeMarkdown } from '@/utils/escapeMarkdown';
import { getInviteTag } from '@/utils/getInviteTag';
import { parseEnv } from '@/utils/parceEnv';
import { differenceInDays, format, formatDistanceToNowStrict, fromUnixTime } from 'date-fns';
import { Action, Command, Ctx, InjectBot, Start, Update } from 'nestjs-telegraf';
import { Context, Scenes, Telegraf } from 'telegraf';
import { InlineKeyboardButton } from 'telegraf/typings/core/types/typegram';
import { SceneContext } from 'telegraf/typings/scenes';

@Update()
export class BotService {
  constructor(
    private apiService: ApiService,
    @InjectBot() private bot: Telegraf<Context>,
  ) {
    bot.telegram.setMyCommands([{ command: '/menu', description: '–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é' }]);
  }

  @Start()
  @Command('menu')
  @Action('mainMenu')
  async onStart(@Ctx() ctx: SceneContext & Context) {
    if (ctx.scene.current) ctx.scene.leave();
    const availableMenu: InlineKeyboardButton[][] = [...mainKeyboard];
    const inviteCode = getInviteTag(ctx.text);

    let user = await this.apiService.findUserByTelegramId(ctx.from?.id!);

    if (!user && !inviteCode) {
      await this.apiService.addTelegramUser(ctx.from!);
      ctx.reply(BOT_DENIED);
      return;
    }

    if (!user && inviteCode) {
      const tgUser = await this.apiService.addTelegramUser(ctx.from!);
      const newUser = await this.apiService.connectByInviteCode(inviteCode, tgUser);
      if (!newUser) {
        ctx.reply('‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π –∫–æ–¥ –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏—è');
        return;
      }

      user = newUser;
    }

    if (!user) {
      ctx.reply(BOT_DENIED);
      return;
    }

    if (user.telegramUser?.id === Number(parseEnv('BOT_OWNER_ID'))) {
      availableMenu.push([
        {
          text: '‚úçüèª –î–µ–π—Å—Ç–≤–∏—è —Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º–∏',
          callback_data: 'userActions',
        },
      ]);
    }

    if (ctx.callbackQuery) {
      await ctx.editMessageText('–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –º–µ–Ω—é –±–æ—Ç–∞ ‚ôø', {
        reply_markup: { inline_keyboard: availableMenu },
      });
      return;
    }

    ctx.reply('–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –º–µ–Ω—é –±–æ—Ç–∞ ‚ôø', {
      reply_markup: { inline_keyboard: availableMenu },
    });
  }

  @Action('profile')
  async profile(@Ctx() ctx: Context) {
    const user = await this.apiService.findUserByTelegramId(ctx.from?.id!);
    if (!user) {
      ctx.reply(BOT_DENIED);
      return;
    }

    const parsedDate = fromUnixTime(user.expire!);
    const dateToExpire = user.expire
      ? `${format(parsedDate, 'dd.MM.yyyy')} (${formatDistanceToNowStrict(parsedDate)})`
      : '‚àû';

    const subPath = new URL(user.subscription_url).pathname;

    const profile = `\`üí° –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –æ–±–Ω–æ–≤–ª—è–µ—Ç—Å—è –≤ 0:00 –ø–æ –ú–°–ö\`

üòé –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: ${escapeMarkdown(user.username)}

üßë‚Äçüíª –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–æ —Ç—Ä–∞—Ñ–∏–∫–∞: ${convertBytes(user.used_traffic)}

üìç –°—Ç–∞—Ç—É—Å: ${user.status}

${
  user.status === 'active' &&
  `üìÖ –î–µ–π—Å—Ç–≤—É–µ—Ç –¥–æ: ${dateToExpire}

üîó –°—Å—ã–ª–∫–∞ –Ω–∞ –ø–æ–¥–ø–∏—Å–∫—É \`\`\`${user.subscription_url}\`\`\`

üîó –ó–µ—Ä–∫–∞–ª–æ \`\`\`${parseEnv('API_HOST')}${subPath}\`\`\`
`
}`.replace(/true|false/, '');

    await ctx.editMessageText(profile, {
      parse_mode: 'Markdown',
      reply_markup: {
        inline_keyboard: [backKeyboard],
      },
    });
  }

  @Action('requisites')
  async requisites(@Ctx() ctx: Context) {
    ctx.editMessageText(requisites, {
      parse_mode: 'Markdown',
      link_preview_options: {
        is_disabled: true,
      },
      reply_markup: {
        inline_keyboard: [backKeyboard],
      },
    });
  }

  @Action('receipt')
  async receipt(@Ctx() ctx: Scenes.SceneContext) {
    const user = await this.apiService.findUserByTelegramId(ctx.callbackQuery?.from.id!);
    if (!user) {
      ctx.reply(BOT_DENIED);
      return;
    }
    if (!user.expire) {
      ctx.editMessageText('–£ –≤–∞—Å –Ω–µ—Ç –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è –Ω–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ', {
        reply_markup: {
          inline_keyboard: [backKeyboard],
        },
      });
      return;
    }
    const expiredDays = differenceInDays(fromUnixTime(user.expire), new Date());
    if (expiredDays > 3 && !isDev) {
      ctx.editMessageText('‚ö†Ô∏è –ß—Ç–æ–±—ã –ø—Ä–æ–¥–ª–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫—É –æ–Ω–∞ –¥–æ–ª–∂–Ω–∞ –∑–∞–∫–∞–Ω—á–∏–≤–∞—Ç—å—Å—è –Ω–µ –±–æ–ª–µ–µ, —á–µ–º —á–µ—Ä–µ–∑ 3 –¥–Ω—è', {
        reply_markup: {
          inline_keyboard: [backKeyboard],
        },
      });
      return;
    }

    ctx.scene.enter('receiptSend');
  }

  @Action('userActions')
  async userActions(@Ctx() ctx: SceneContext) {
    ctx.scene.enter('userActions');
  }

  async sendToOwner({ type, content, senderName }: SendToOwner) {
    switch (type) {
      case 'document':
        this.bot.telegram.sendDocument(parseEnv('BOT_OWNER_ID'), content, {
          caption: `–í–ª–æ–∂–µ–Ω–∏–µ –æ—Ç #${senderName}`,
        });
        break;
      case 'photo':
        this.bot.telegram.sendPhoto(parseEnv('BOT_OWNER_ID'), content, {
          caption: `–í–ª–æ–∂–µ–Ω–∏–µ –æ—Ç #${senderName}`,
        });
        break;
      case 'text':
        this.bot.telegram.sendMessage(parseEnv('BOT_OWNER_ID'), content);
        break;
    }
  }
}
